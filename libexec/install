#!/usr/bin/env bash

set -o errexit -o pipefail

main() {
    init

    #@ -h,--help | print this text
    #@ install | install package/group
    
    for n in "$@"; do
	case "$n" in
	    "@"*)
		install::group "$n"
		;;
	    *)
		install::package "$n"
		;;
	esac
    done
}

install::find_package() {
    local name="${1:?}"

    for d in "${SELF_DIR:?}"/pkgs/**/"${name}"; do
	# FIXME: This assumes there are no package name conflicts
	package="$d"
	break
    done

    if [[ -z "$package" ]]; then
	log::fatal "Could not find path associated with package: $name"
    fi
    
    printf '%s' "$package"
}

install::dependencies() {
    local package="${1:?}"

    log::debug "Checking for dependencies."
    
    local dependencies="${package}/REQUIRE"
    if [[ ! -f "$dependencies" ]]; then
	log::debug "No dependencies found. Path '$dependencies' does not exist. Skipping."
	return 0
    fi

    # FIXME: Refactor to remove the ||
    while read -r line || [[ -n "$line"  ]]; do
	if [[ -z "$line" ]]; then
	    continue
	fi
	
	log::info "Installing dependency '$line'."
	install::package "$line"
    done < "$dependencies"
}

install::group() {
    local name="${1:?}"

    local group="${SELF_DIR}/pkgs/group/${name}/ALIAS"
    if [[ ! -f "$group" ]]; then
	log::debug "Path '$group' does not exist."
	log::fatal "Group '$name' does not exist."
    fi

    # FIXME: Refactor to remove the ||
    while read -r line || [[ -n "$line"  ]]; do
	if [[ -z "$line" ]]; then
	    continue
	fi
	
	install::package "$line"
    done < "$group"
}

install::package() {
    set -- $(string::split "${1:?}" "@")

    local name="$1"
    local version="$2"
    
    local package
    package="$(install::find_package "$name")"
    log::debug "Found package: ${package}"

    install::dependencies "$package"
    
    if [[ ! -f "${package}/SOURCE" ]]; then
	log::debug "Path '$package' does not exist."
	log::fatal "Package '$name' does not exist."
    fi

    log::info "Installing $name"
    source "${package}/SOURCE"

    PKG_DIR="$package"
    PKG_NAME="$name"

    local key val
    for f in "${package}/vars/"*; do
	key="vars_${f##*/}"
	val="$(<"$f")"

	log::debug "Setting variable '$key' to value '$val'"
	eval export ${key}="${val}"
    done

    PKG_REF="${vars_default_branch:?}"
    if [[ -n "$version"  ]]; then	
	log::debug "Ref overridden for package '$name': Installing version $version"
	PKG_REF="$version"
    fi

    export PKG_DATA_DIR="${CMD_DATA_DIR}/${PKG_NAME}"
    export PKG_SRC_DIR="${PKG_DATA_DIR}/src" # Source code
    export PKG_REF PKG_DIR PKG_NAME

    # Pretty much a one-for-one clone of Gentoo's ebuild phase functions
    declare -a external_phases=(
	pkg_pretend
	pkg_setup
	src_unpack
	src_prepare
	src_configure
	src_build
	src_test
	src_install
	pkg_preinst
	pkg_postinst
    )

    declare -a internal_pre_phases=(
	sys_setpfx
    )

    declare -a internal_post_phases=(
	sys_setpath
	sys_markinstalled
    )

    # TODO: is there a better spot for these functions than nesting them here?
    sys_setpfx() {
	# Each package version gets it's own install prefix
	export PKG_PFX_DIR="${PKG_DATA_DIR:?}/pfx/${PKG_REF:?}"
	log::debug "Install prefix: $PKG_PFX_DIR"
	fs::mkdir "$PKG_PFX_DIR"

	# Set the active package version. This gets added to the user's PATH
	ln -srf "$PKG_PFX_DIR" "${PKG_DATA_DIR:?}/pfx/_"
    }

    sys_setpath(){
	# After install add executables to the final bin path
	if [[ ! -d "${PKG_DATA_DIR:?}/pfx/_/bin" ]]; then
	   log::debug "Path '${PKG_DATA_DIR:?}/pfx/_/bin' does not exist. Skipping."
	   return 0
	fi

	for b in "${PKG_DATA_DIR:?}/pfx/_/bin/"*; do
	    log::debug "Symlinking '$b' to '${SELF_BIN_DIR:?}'"
	    ln -srf "$b" "${SELF_BIN_DIR:?}"
	done
    }

    sys_markinstalled() {
	fs::mkdir "${SELF_INDEX_DIR:?}/${PKG_NAME:?}/${PKG_REF:?}"
    }

    phases=(${internal_pre_phases[@]} ${external_phases[@]} ${internal_post_phases[@]})

    # FIXME: if there is a tag any of the following keywords it will be ignored.
    case "$version" in
	stable)
	    phases=(usr_stable_version ${phases[@]})
	    ;;
	latest)
	    phases=(usr_latest_version ${phases[@]})
	    ;;
    esac

    fs::mkdir "$PKG_SRC_DIR"

    log::debug "Entering directory: $PKG_SRC_DIR"
    pushd "$PKG_SRC_DIR"

    # Prioritize our package's for the duration of the install
    if [[ "$PATH" != "${SELF_BIN_DIR}:"* ]]; then
	log::debug "Adding the following to PATH environment: ${SELF_BIN_DIR}"
	PATH="${SELF_BIN_DIR}:${PATH}"
    fi

    local count
    for p in "${phases[@]}"; do
	log::debug "Starting phase: $p"
	case "$p" in
	    usr_stable_version|usr_latest_version)
		PKG_REF=$("$p")
		log::debug "Assigned ref to: $PKG_REF"
		continue
		;;
	    # FIXME: If the source already exists locally no attempts will be made to update them
	    src_unpack)
		count=$(fs::count "${PKG_SRC_DIR}/"*)
		if [[ $count -gt 1 ]]; then
		    log::debug "Skipping phase '$p'. Source already exists in directory: ${PKG_SRC_DIR}"
		    continue
		fi
		;;
	    sys_*)
		# sys_* phases are internal, will always exist and should be invoked in the current shell
		"$p"
		continue
		;;
	esac

	fn::exists "$p" && {
	    log::debug "Executing phase function '$p' for package '$package'"
	    ("$p")
	}
    done

    log::debug "Leaving directory: $PWD"
    popd
    unset "${external_phases[@]}"
}

main "$@"
