#!/usr/bin/env bash

set -o errexit -o pipefail

SELF="$(readlink -f "$0")" # Absolute path
SELF_DIR="$(dirname "$SELF")"
SELF_NAME="rafi"
export SELF SELF_DIR SELF_NAME

export SELF_CONFIG_DIR="${XDG_CONFIG_HOME:-${HOME}/.config}/${SELF_NAME}"
export SELF_STATE_DIR="${XDG_STATE_HOME:-${HOME}/.local/state}/${SELF_NAME}"
export SELF_DATA_DIR="${XDG_DATA_HOME:-${HOME}/.local/share}/${SELF_NAME}"
export SELF_BIN_DIR="${XDG_DATA_HOME:-${HOME}/.local/share}/${SELF_NAME}/_/bin"
export SELF_INDEX_DIR="${XDG_STATE_HOME:-${HOME}/.local/state}/${SELF_NAME}/_"

DEBUG=${DEBUG:-0}
DRYRUN=${DRYRUN:-0}
CLEAN=${CLEAN:-1}

ARGV=()

usage::print() {
    # Usage: usage::print file
    log::debug "Reading $1"

    declare -a cmd
    cmd=("${0##*/}")
    if [[ "$0" != "$1" ]]; then
	cmd+=("${1##*/}")
    fi

    printf '%s: %s\n' "Version" "$(<"${SELF_DIR}/VERSION")" 
    
    printf '\n%s:\n' "Environment"
    printf '%s 0/1\n  %s\n' "DEBUG" "Print debug logs. Default is 0" "DRYRUN" "Do not execute commands only print them. Default is 0"
    
    printf '\n%s: %s\n' "Usage" "${cmd[*]}"
    while read -r line; do
	tmp="$(string::trim "$line")"
	if [[ "$tmp" == "#@"* ]]; then
	    declare -a wrkarr
	    tmp="${tmp###@ }"

	    IFS= wrkarr=($(string::split "${tmp###@ }" "|"))

	    printf '%s\n' "${wrkarr[0]}"     # argument
	    printf '  %s\n' "${wrkarr[*]:1}" # description
	fi
    done < "$1"
}

self::install() {
    # Usage: self::install

    local bin_dir="${DESTDIR:-${HOME}/.local}/bin"
    declare -a dirs=(
	"$SELF_CONFIG_DIR" "$SELF_DATA_DIR" "$SELF_STATE_DIR" "$bin_dir"
    )

    for d in "${dirs[@]}"; do
	if [[ -d "$d" ]]; then
	    continue
	fi
	mkdir -p "$d"
    done

    ln -srf "${0##*/}" "${bin_dir}/${SELF_NAME}"
    printf '%s\n' "Installed to ${bin_dir}/${SELF_NAME}"
}

self::configure_bash() {
    # Usage: self::configure_bash
    if [[ "$PATH" == *"${SELF_BIN_DIR}"* ]]; then
	return 0
    fi

    printf '%s\n' "source <(printf '%s\n' PATH=\"${SELF_BIN_DIR}:\$PATH\")"
}

arg::parse() {
    # Usage:: arg::parse
    declare -a targets

    local found_subcommand=0
    while [[ $# -gt 0 ]]; do
        local argv="$1"

        case "$argv" in
	    #@ -h,--help | Print this text
	    -h|--help)
		local usage_source_file
		usage_source_file="${SELF_DIR}/libexec/${targets[0]}"
		if [[ -z "${targets[0]}" ]]; then
		    usage_source_file="$0"
		fi
		
		usage::print "$usage_source_file"
		exit 0
		;;
	    [[:alpha:]]*)
		found_subcommand=1
		targets+=("$argv")
		shift
		;;
            -*)
		if [[ $found_subcommand -eq 1 ]]; then
		    targets+=("$argv")
		    shift
		    continue
		fi

		log::_fatal 128 "Invalid option: $argv" >&2
                ;;
            *)
                targets+=("$argv")
                shift
                ;;
        esac

        regex_requires_no_arg="^--with(out)?-[A-Za-z-]+"
        if [[ "$argv" =~ $regex_requires_no_arg ]]; then
            shift
        elif [[ "$argv" == "--"* ]]; then
            shift 2
        fi
    done

    ARGV=("${targets[@]}")
}

bootstrap() {
    # This is written in such a way for the sake of performance. It's not pretty to look at. Func 'bootstrap'
    # is the first thing called in 'main'. These subcommands will get called often so it's important we do as
    # little before hand (i.e, no directory traversal, sourcing files), otherwise we'll contribute to slowdown
    # when executed inside a .rc file.

    if [[ "$1" != "bootstrap" ]] && [[ "$1" != "init" ]]; then
	init
	return 0
    fi

    case "$2" in
	#@ bootstrap install | Install self
	install)
	    self::install
	    ;;
	#@ init bash | Print lines that are to be added to your bashrc
	bash)
	    self::configure_bash
	    ;;
	*)
	    exit 128
	    ;;
    esac

    exit 0
}

init() {
    # Usage: init
    for f in "${SELF_DIR}/lib/"*.sh; do
	if [[ $DEBUG -eq 1 ]]; then
	    printf '%s\n' "Loading library: $f"
	fi
	source "$f"
    done
}

main() {
    bootstrap "$@"

    # arg::parse sets global variable ARGV
    arg::parse "$@"
    
    # Builtins
    case "${ARGV[0]}" in
	#@ help | Print this text
	''|h|help)
	    usage::print "$0"
	    exit 0
	    ;;
    esac
    
    export CLEAN DEBUG DRYRUN
    export CMD_CONFIG_DIR="${SELF_CONFIG_DIR:?}/${ARGV[0]}"
    export CMD_DATA_DIR="${SELF_DATA_DIR:?}/${ARGV[0]}"
    export CMD_STATE_DIR="${SELF_STATE_DIR:?}/${ARGV[0]}"
    export -f init

    fs::mkdir "$SELF_BIN_DIR" "$CMD_CONFIG_DIR" "$CMD_DATA_DIR" "$CMD_STATE_DIR"

    local subcommand="${SELF_DIR}/libexec/${ARGV[0]}"
    if [[ -n "${ARGV[0]}" ]]; then
	if [[ -x "$subcommand" ]]; then	    
	    log::debug "Executing command '$subcommand' with arguments: ${argv[*]:1}"
	    exec "$subcommand" "${ARGV[@]:1}"
	elif [[ ! -e "$subcommand" ]]; then
	    log::fatal "Command '$subcommand' does not exist."
	else
	    log::fatal "Command '$subcommand' is not executable."
	fi
    fi

    log::_fatal 128 "Invalid argument: '${ARGV[0]}'." >&2
}

main "$@"
