#!/usr/bin/env bash

set -o errexit -o pipefail

SELF="$(readlink -f "$0")" # Absolute path
SELF_DIR="$(dirname "$SELF")"
SELF_NAME="rafi"
export SELF SELF_DIR SELF_NAME

export SELF_CONFIG_DIR="${XDG_CONFIG_HOME:-${HOME}/.config}/${SELF_NAME}"
export SELF_STATE_DIR="${XDG_STATE_HOME:-${HOME}/.local/state}/${SELF_NAME}"
export SELF_DATA_DIR="${XDG_DATA_HOME:-${HOME}/.local/share}/${SELF_NAME}"

DEBUG=${DEBUG:-0}
DRYRUN=${DRYRUN:-0}
CLEAN=${CLEAN:-1}

ARGV=()

usage::print() {
    # Usage: usage::print file
    log::debug "Reading $1"

    declare -a cmd
    cmd=("${0##*/}")
    if [[ "$0" != "$1" ]]; then
	cmd+=("${1##*/}")
    fi

    printf '%s: %s\n' "Version" "$(<"${SELF_DIR}/VERSION")" 
    
    printf '\n%s:\n' "Environment"
    printf '%s 0/1\n  %s\n' "DEBUG" "Print debug logs. Default is 0" "DRYRUN" "Do not execute commands only print them. Default is 0"
    
    printf '\n%s: %s\n' "Usage" "${cmd[*]}"
    while read -r line; do
	tmp="$(string::trim "$line")"
	if [[ "$tmp" == "#@"* ]]; then
	    arr=($(string::split "${tmp###@ }" "|"))
	    printf '%s\n' "${arr[0]}"     # argument
	    printf '  %s\n' "${arr[*]:1}" # description
	fi
    done < "$1"
}

self::bootstrap() {
    # Usage: self::bootstrap

    # It's import no external functions are referenced here
    mkdir -p "$SELF_CONFIG_DIR" "$SELF_DATA_DIR" "$SELF_STATE_DIR"

    local dest="${DESTDIR:-${HOME}/.local}/bin/${SELF_NAME}"
    if [[ ! -L "$dest" ]]; then
	ln -sr "${0##*/}" "$dest"
    fi
}

arg::parse() {
    # Usage:: arg::parse
    declare -a targets

    local found_subcommand=0
    while [[ $# -gt 0 ]]; do
        local argv="$1"

        case "$argv" in
	    #@ -h,--help | Print this text
	    -h|--help)
		local usage_source_file
		usage_source_file="${SELF_DIR}/libexec/${targets[0]}"
		if [[ -z "${targets[0]}" ]]; then
		    usage_source_file="$0"
		fi
		
		usage::print "$usage_source_file"
		exit 0
		;;
	    [[:alpha:]]*)
		found_subcommand=1
		targets+=("$argv")
		shift
		;;
            -*)
		if [[ $found_subcommand -eq 1 ]]; then
		    targets+=("$argv")
		    shift
		    continue
		fi

		log::_fatal 128 "Invalid option: $argv" >&2
                ;;
            *)
                targets+=("$argv")
                shift
                ;;
        esac

        regex_requires_no_arg="^--with(out)?-[A-Za-z-]+"
        if [[ "$argv" =~ $regex_requires_no_arg ]]; then
            shift
        elif [[ "$argv" == "--"* ]]; then
            shift 2
        fi
    done

    ARGV=("${targets[@]}")
}

init() {
    # Usage: init
    for f in "${SELF_DIR}/lib/"*.sh; do
	if [[ $DEBUG -eq 1 ]]; then
	    printf '%s\n' "Loading library: $f"
	fi
	source "$f"
    done
}

main() {
    #@ i,init | create config directory
    case "$1" in
	i|init)
	    self::bootstrap
	    exit 0
	    ;;
    esac

    init

    # arg::parse sets global variable ARGV
    arg::parse "$@"
    
    # Builtins
    case "${ARGV[0]}" in
	#@ help | print this text
	''|h|help)
	    usage::print "$0"
	    exit 0
	    ;;
    esac
    
    export CLEAN DEBUG DRYRUN
    export CMD_CONFIG_DIR="${SELF_CONFIG_DIR:?}/${ARGV[0]}"
    export CMD_DATA_DIR="${SELF_DATA_DIR:?}/${ARGV[0]}"
    export CMD_STATE_DIR="${SELF_STATE_DIR:?}/${ARGV[0]}"
    export -f init

    fs::mkdir "$CMD_CONFIG_DIR" "$CMD_DATA_DIR" "$CMD_STATE_DIR"

    local subcommand="${SELF_DIR}/libexec/${ARGV[0]}"
    if [[ -n "${ARGV[0]}" ]]; then
	if [[ -x "$subcommand" ]]; then	    
	    log::debug "Executing command '$subcommand' with arguments: ${argv[*]:1}"
	    exec "$subcommand" "${ARGV[@]:1}"
	elif [[ ! -e "$subcommand" ]]; then
	    log::fatal "Command '$subcommand' does not exist."
	else
	    log::fatal "Command '$subcommand' is not executable."
	fi
    fi

    log::_fatal 128 "Invalid argument: '${ARGV[0]}'." >&2
}

main "$@"
